}
}
if (nrow(unhappyPeople) > 0) {
nMovements = length(vacant[,1])
if ( nMovements > length(unhappyPeople[,1])) {
nMovements = length(unhappyPeople[,1])
}
sampleIndices = sample(1:length(unhappyPeople[,1]),nMovements)
vacancySamples = sample(1:length(vacant[,1]),nMovements)
for (index in 1:nMovements) {
vacancyIndex = vacancySamples[index]
vacantRow = vacant[vacancyIndex,1]
vacantCol = vacant[vacancyIndex,2]
moverRow = unhappyPeople[sampleIndices[index],1]
moverCol = unhappyPeople[sampleIndices[index],2]
world[vacantRow,vacantCol] = world[moverRow,moverCol]
world[moverRow,moverCol] = -1
}
image(world, col=colors)
} else {
image(world, col=colors)
break
}
}
rows = 100
size = rows^2
world <- matrix(4,nrow=rows,ncol=rows)
world[sample(1:size,round(size*.5))] = 1
world[sample(1:size,round(size*.05))] = -1
bias = matrix(1/3,nrow=rows,ncol=rows)
colorFunc = colorRampPalette(c("white","black"))
image(bias,col=colorFunc(10))
colors = c("black","Red","orange","green","blue")
image(world, col=colors)
for (time in 1:1000){
vacant = data.frame()
unhappyPeople = data.frame()
print(time)
for (row in 1:rows) {
for (col in 1:rows) {
value = world[row,col]
if (value > 0) {
neighbors = c(0,0,0,0)
directions = list(c(row + 1, col),
c(row + 1, col + 1),
c(row,     col + 1),
c(row - 1, col + 1),
c(row - 1, col),
c(row - 1, col - 1),
c(row,     col - 1),
c(row + 1, col - 1))
for (directionIndex in 1:8) {
rowN = directions[[directionIndex]][1]
colN = directions[[directionIndex]][2]
# Check for overflows
if (rowN > rows) {
rowN = rowN - rows
} else if (rowN < 1) {
rowN = rows - rowN
}
if (colN > rows) {
colN = colN - rows
} else if (colN < 1) {
colN = rows - colN
}
neighborValue = world[rowN,colN]
if (neighborValue > 0){
neighbors[neighborValue] = neighbors[neighborValue] + 1
}
}
if (value < 3 && sum(neighbors) > 0){
neighborhood = sum(neighbors[1:2]) / sum(neighbors)
if (neighborhood <= bias[row,col]) {
world[row,col] = 2
unhappyPeople = rbind(unhappyPeople,c(row,col))
} else {
world[row,col] = 1
}
} else if (value > 2 && sum(neighbors) > 0) {
neighborhood = sum(neighbors[3:4]) / sum(neighbors)
if (neighborhood <= bias[row,col]) {
unhappyPeople = rbind(unhappyPeople,c(row,col))
world[row,col] = 3
} else {
world[row,col] = 4
}
}
} else {
vacant = rbind(vacant,c(row,col))
}
}
}
if (nrow(unhappyPeople) > 0) {
nMovements = length(vacant[,1])
if ( nMovements > length(unhappyPeople[,1])) {
nMovements = length(unhappyPeople[,1])
}
sampleIndices = sample(1:length(unhappyPeople[,1]),nMovements)
vacancySamples = sample(1:length(vacant[,1]),nMovements)
for (index in 1:nMovements) {
vacancyIndex = vacancySamples[index]
vacantRow = vacant[vacancyIndex,1]
vacantCol = vacant[vacancyIndex,2]
moverRow = unhappyPeople[sampleIndices[index],1]
moverCol = unhappyPeople[sampleIndices[index],2]
world[vacantRow,vacantCol] = world[moverRow,moverCol]
world[moverRow,moverCol] = -1
}
image(world, col=colors)
} else {
image(world, col=colors)
break
}
}
rows = 200
size = rows^2
world <- matrix(4,nrow=rows,ncol=rows)
world[sample(1:size,round(size*.5))] = 1
world[sample(1:size,round(size*.05))] = -1
bias = matrix(1/3,nrow=rows,ncol=rows)
colorFunc = colorRampPalette(c("white","black"))
image(bias,col=colorFunc(10))
colors = c("black","Red","orange","green","blue")
image(world, col=colors)
for (time in 1:1000){
vacant = data.frame()
unhappyPeople = data.frame()
print(time)
for (row in 1:rows) {
for (col in 1:rows) {
value = world[row,col]
if (value > 0) {
neighbors = c(0,0,0,0)
directions = list(c(row + 1, col),
c(row + 1, col + 1),
c(row,     col + 1),
c(row - 1, col + 1),
c(row - 1, col),
c(row - 1, col - 1),
c(row,     col - 1),
c(row + 1, col - 1))
for (directionIndex in 1:8) {
rowN = directions[[directionIndex]][1]
colN = directions[[directionIndex]][2]
# Check for overflows
if (rowN > rows) {
rowN = rowN - rows
} else if (rowN < 1) {
rowN = rows - rowN
}
if (colN > rows) {
colN = colN - rows
} else if (colN < 1) {
colN = rows - colN
}
neighborValue = world[rowN,colN]
if (neighborValue > 0){
neighbors[neighborValue] = neighbors[neighborValue] + 1
}
}
if (value < 3 && sum(neighbors) > 0){
neighborhood = sum(neighbors[1:2]) / sum(neighbors)
if (neighborhood <= bias[row,col]) {
world[row,col] = 2
unhappyPeople = rbind(unhappyPeople,c(row,col))
} else {
world[row,col] = 1
}
} else if (value > 2 && sum(neighbors) > 0) {
neighborhood = sum(neighbors[3:4]) / sum(neighbors)
if (neighborhood <= bias[row,col]) {
unhappyPeople = rbind(unhappyPeople,c(row,col))
world[row,col] = 3
} else {
world[row,col] = 4
}
}
} else {
vacant = rbind(vacant,c(row,col))
}
}
}
if (nrow(unhappyPeople) > 0) {
nMovements = length(vacant[,1])
if ( nMovements > length(unhappyPeople[,1])) {
nMovements = length(unhappyPeople[,1])
}
sampleIndices = sample(1:length(unhappyPeople[,1]),nMovements)
vacancySamples = sample(1:length(vacant[,1]),nMovements)
for (index in 1:nMovements) {
vacancyIndex = vacancySamples[index]
vacantRow = vacant[vacancyIndex,1]
vacantCol = vacant[vacancyIndex,2]
moverRow = unhappyPeople[sampleIndices[index],1]
moverCol = unhappyPeople[sampleIndices[index],2]
world[vacantRow,vacantCol] = world[moverRow,moverCol]
world[moverRow,moverCol] = -1
}
image(world, col=colors)
} else {
image(world, col=colors)
break
}
}
rows = 200
size = rows^2
world <- matrix(4,nrow=rows,ncol=rows)
world[sample(1:size,round(size*.5))] = 1
world[sample(1:size,round(size*.05))] = -1
bias = matrix(1/2,nrow=rows,ncol=rows)
colorFunc = colorRampPalette(c("white","black"))
image(bias,col=colorFunc(10))
colors = c("black","Red","orange","green","blue")
image(world, col=colors)
for (time in 1:1000){
vacant = data.frame()
unhappyPeople = data.frame()
print(time)
for (row in 1:rows) {
for (col in 1:rows) {
value = world[row,col]
if (value > 0) {
neighbors = c(0,0,0,0)
directions = list(c(row + 1, col),
c(row + 1, col + 1),
c(row,     col + 1),
c(row - 1, col + 1),
c(row - 1, col),
c(row - 1, col - 1),
c(row,     col - 1),
c(row + 1, col - 1))
for (directionIndex in 1:8) {
rowN = directions[[directionIndex]][1]
colN = directions[[directionIndex]][2]
# Check for overflows
if (rowN > rows) {
rowN = rowN - rows
} else if (rowN < 1) {
rowN = rows - rowN
}
if (colN > rows) {
colN = colN - rows
} else if (colN < 1) {
colN = rows - colN
}
neighborValue = world[rowN,colN]
if (neighborValue > 0){
neighbors[neighborValue] = neighbors[neighborValue] + 1
}
}
if (value < 3 && sum(neighbors) > 0){
neighborhood = sum(neighbors[1:2]) / sum(neighbors)
if (neighborhood <= bias[row,col]) {
world[row,col] = 2
unhappyPeople = rbind(unhappyPeople,c(row,col))
} else {
world[row,col] = 1
}
} else if (value > 2 && sum(neighbors) > 0) {
neighborhood = sum(neighbors[3:4]) / sum(neighbors)
if (neighborhood <= bias[row,col]) {
unhappyPeople = rbind(unhappyPeople,c(row,col))
world[row,col] = 3
} else {
world[row,col] = 4
}
}
} else {
vacant = rbind(vacant,c(row,col))
}
}
}
if (nrow(unhappyPeople) > 0) {
nMovements = length(vacant[,1])
if ( nMovements > length(unhappyPeople[,1])) {
nMovements = length(unhappyPeople[,1])
}
sampleIndices = sample(1:length(unhappyPeople[,1]),nMovements)
vacancySamples = sample(1:length(vacant[,1]),nMovements)
for (index in 1:nMovements) {
vacancyIndex = vacancySamples[index]
vacantRow = vacant[vacancyIndex,1]
vacantCol = vacant[vacancyIndex,2]
moverRow = unhappyPeople[sampleIndices[index],1]
moverCol = unhappyPeople[sampleIndices[index],2]
world[vacantRow,vacantCol] = world[moverRow,moverCol]
world[moverRow,moverCol] = -1
}
image(world, col=colors)
} else {
image(world, col=colors)
break
}
}
setwd("~/")
data <- read.csv("participation.csv")
mean(data$participation)
data
View(data)
hist(data)
hist(data$participation)
mean(data$participation)
median(data$participation)
boxplot(data$participation)
data <- read.csv("participation.csv")
mean(data$participation)
median(data$participation)
boxplot(data$participation)
data <- read.csv("participation.csv")
mean(data$participation)
median(data$participation)
boxplot(data$participation)
plot(data$participation)
plot(data$participation,type="l")
plot(data$participation,type="b")
plot(data$participation,type="b",pch=19)
plot(data$participation,type="b",pch=19,
xlab="Day of Class",
ylab="Number of Participation Events")
setwd("~/projects/computer_vision/chromosome-count/data/stacks/uncompressed")
require(vioplot)
#data <- read.csv("densities.csv")
data1 <- read.csv("A_Early stages of daughter cell formation//densities.csv")
data2 <- read.csv("B_Fully engulfed, small daughter cells//densities.csv")
data3 <- read.csv('C_Fully engulfed, full length daughter cells//densities.csv')
data <- rbind(data1,data2)
data <- rbind(data,data3)
stageStrings = c("A","B","C")
# Separate data by life cycle stage
stages = c()
for (row in 1:nrow(data)) {
stageString = strsplit(as.character(data$analysis[row]),"_")[[1]][1]
stage = which(stageString == stageStrings)
stages = append(stages, stage)
}
data <- cbind(data, stage = stages)
stages = split(data, data$stage)
# Boxplot of the data by stage
boxplot(1/stages[[1]]$density,
1/stages[[2]]$density,
1/stages[[3]]$density,
ylab = "Cubic Micrometers Per Chromosome",
xlab = "Life Cycle Stage",
main = "Distribution of Chromosome Density of Euplopiscium by Stage",
names = names(stages))
abline(h=1.9,col="blue")
# Number of chromosomes vs. volume colored by stage
plot(data$volume, data$chromosomes,col=rainbow(max(data$stage))[data$stage],pch=19,
ylab= "Number of Chromosomes",
xlab= "Cell Volume (um^3)",
main= "Number of Chromosomes vs. Volume by Life Cycle Stage")
legend("topleft",legend=names(stages),fill=rainbow(max(data$stage))[as.numeric(names(stages))])
model <- lm(data$chromosomes~data$volume-1)
summary(model)
abline(model,col="red")
abline(a=0,b=1/1.9,col='blue')
cat(paste("Density:",1/model$coefficients[1],"um^3 per genome."))
vioplot(1/stages[[1]]$density,
1/stages[[2]]$density,
1/stages[[3]]$density)
vioplot(1/stages[[1]]$density,
1/stages[[2]]$density,
1/stages[[3]]$density,
col="lightblue")
vioplot(1/stages[[1]]$density,
1/stages[[2]]$density,
1/stages[[3]]$density,
col="lightblue",
ylab = "Cubic Micrometers Per Chromosome",
xlab = "Life Cycle Stage",
main = "Distribution of Chromosome Density of Euplopiscium by Stage",
names = names(stages))
vioplot(1/stages[[1]]$density,
1/stages[[2]]$density,
1/stages[[3]]$density,
col="lightblue",
ylab = "Cubic Micrometers Per Chromosome",
xlab = "Life Cycle Stage",
main = "Distribution of Chromosome Density of Euplopiscium by Stage")
vioplot(1/stages[[1]]$density,
1/stages[[2]]$density,
1/stages[[3]]$density,
col="lightblue")
title( ylab = "Cubic Micrometers Per Chromosome",
xlab = "Life Cycle Stage",
main = "Distribution of Chromosome Density of Euplopiscium by Stage")
setwd("~/projects/computer_vision/chromosome-count/data/stacks/uncompressed/A_Early stages of daughter cell formation")
source('~/projects/computer_vision/chromosome-count/analysis/plotter.R', echo=TRUE)
setwd("~/projects/computer_vision/chromosome-count/data/stacks/uncompressed")
require(vioplot)
#data <- read.csv("densities.csv")
data1 <- read.csv("A_Early stages of daughter cell formation//densities.csv")
data2 <- read.csv("B_Fully engulfed, small daughter cells//densities.csv")
data3 <- read.csv('C_Fully engulfed, full length daughter cells//densities.csv')
data <- rbind(data1,data2)
data <- rbind(data,data3)
stageStrings = c("A","B","C")
# Separate data by life cycle stage
stages = c()
for (row in 1:nrow(data)) {
stageString = strsplit(as.character(data$analysis[row]),"_")[[1]][1]
stage = which(stageString == stageStrings)
stages = append(stages, stage)
}
data <- cbind(data, stage = stages)
stages = split(data, data$stage)
# Boxplot of the data by stage
boxplot(1/stages[[1]]$density,
1/stages[[2]]$density,
1/stages[[3]]$density,
ylab = "Cubic Micrometers Per Chromosome",
xlab = "Life Cycle Stage",
main = "Distribution of Chromosome Density of Euplopiscium by Stage",
names = names(stages))
abline(h=1.9,col="blue")
vioplot(1/stages[[1]]$density,
1/stages[[2]]$density,
1/stages[[3]]$density,
col="lightblue")
title( ylab = "Cubic Micrometers Per Chromosome",
xlab = "Life Cycle Stage",
main = "Distribution of Chromosome Density of Euplopiscium by Stage")
# Number of chromosomes vs. volume colored by stage
plot(data$volume, data$chromosomes,col=rainbow(max(data$stage))[data$stage],pch=19,
ylab= "Number of Chromosomes",
xlab= "Cell Volume (um^3)",
main= "Number of Chromosomes vs. Volume by Life Cycle Stage")
legend("topleft",legend=names(stages),fill=rainbow(max(data$stage))[as.numeric(names(stages))])
model <- lm(data$chromosomes~data$volume-1)
summary(model)
abline(model,col="red")
abline(a=0,b=1/1.9,col='blue')
cat(paste("Density:",1/model$coefficients[1],"um^3 per genome."))
legend("topleft",legend=stageStrings,fill=rainbow(max(data$stage))[as.numeric(names(stages))])
setwd("~/projects/data_analysis/geneseo_yikyak")
data <- read.csv("allposts.csv")
data
data <- read.csv("allposts.csv")
data <- read.csv("allposts_fixed.csv")
data <- read.csv("allposts_fixed.csv",header=F)
hist(data$V3)
hist(data$V3,breaks=1000)
names(data) <- c("ID","string","score")
hist(data$string,breaks=1000)
which(data$score==max(data$score))
data[132099,]
require("tm")
rm(list=ls())
par(mfrow=c(1,1))
packages <- c('tm')
for (index in 1:length(packages)){
package = packages[index]
exists = require(package,character.only = T)
if (exists == FALSE) {
install.packages(package)
require(package,character.only = T)
}
}
data <- read.csv("allposts_fixed.csv",header=F)
names(data) <- c("ID","string","score")
corpus <- Corpus(data$string)
corpus <- Corpus(VectorSource(data$string))
corpus <- tm_map(corpus,tolower)
corpus <- tm_map(corpus,removePunctuation)
dictCorpus <- corpus
corpus <- tm_map(corpus, stemDocument)
inspect(corpus[1:5])
rm(list=ls())
par(mfrow=c(1,1))
packages <- c('tm','snowballC')
for (index in 1:length(packages)){
package = packages[index]
exists = require(package,character.only = T)
if (exists == FALSE) {
install.packages(package)
require(package,character.only = T)
}
}
data <- read.csv("allposts_fixed.csv",header=F)
names(data) <- c("ID","string","score")
corpus <- Corpus(VectorSource(data$string))
# Remove punctionation and convert to lowercase
corpus <- tm_map(corpus,tolower)
corpus <- tm_map(corpus,removePunctuation)
inspect(corpus[1:3])
stemcorpus <- tm_map(corpus, stemDocument)
inspect(stemcorpus[1:3])
documentMatrix <- TermDocumentMatrix(corpus, control = list(minWordLength = 1))
inspect(documentMatrix)
corpus <- tm_map(corpus,stemDocument,lazy=TRUE)
documentMatrix <- TermDocumentMatrix(corpus, control = list(minWordLength = 1))
documentMatrix <- TermDocumentMatrix(corpus, control = list(minWordLength = 1),lazy=TRUE)
rm(list=ls())
par(mfrow=c(1,1))
packages <- c('tm','SnowballC')
for (index in 1:length(packages)){
package = packages[index]
exists = require(package,character.only = T)
if (exists == FALSE) {
install.packages(package)
require(package,character.only = T)
}
}
inspect(corpus)
data <- read.csv("allposts_fixed.csv",header=F)
names(data) <- c("ID","string","score")
corpus <- Corpus(VectorSource(data$string))
# Remove punctionation and convert to lowercase
corpus <- tm_map(corpus,tolower)
corpus <- tm_map(corpus,removePunctuation)
corpusBackup <- corpus
corpus <- tm_map(corpus,stemDocument,lazy=TRUE)
