image(world, col=colors)
for (time in 1:1000){
vacant = data.frame()
unhappyPeople = data.frame()
print(time)
for (row in 1:rows) {
for (col in 1:rows) {
value = world[row,col]
if (value > 0) {
neighbors = c(0,0,0,0)
directions = list(c(row + 1, col),
c(row + 1, col + 1),
c(row,     col + 1),
c(row - 1, col + 1),
c(row - 1, col),
c(row - 1, col - 1),
c(row,     col - 1),
c(row + 1, col - 1))
for (directionIndex in 1:8) {
rowN = directions[[directionIndex]][1]
colN = directions[[directionIndex]][2]
# Check for overflows
if (rowN > rows) {
rowN = rowN - rows
} else if (rowN < 1) {
rowN = rows - rowN
}
if (colN > rows) {
colN = colN - rows
} else if (colN < 1) {
colN = rows - colN
}
neighborValue = world[rowN,colN]
if (neighborValue > 0){
neighbors[neighborValue] = neighbors[neighborValue] + 1
}
}
if (value < 3 && sum(neighbors) > 0){
neighborhood = sum(neighbors[1:2]) / sum(neighbors)
if (neighborhood <= bias[row,col]) {
world[row,col] = 2
unhappyPeople = rbind(unhappyPeople,c(row,col))
} else {
world[row,col] = 1
}
} else if (value > 2 && sum(neighbors) > 0) {
neighborhood = sum(neighbors[3:4]) / sum(neighbors)
if (neighborhood <= bias[row,col]) {
unhappyPeople = rbind(unhappyPeople,c(row,col))
world[row,col] = 3
} else {
world[row,col] = 4
}
}
} else {
vacant = rbind(vacant,c(row,col))
}
}
}
if (nrow(unhappyPeople) > 0) {
nMovements = length(vacant[,1])
if ( nMovements > length(unhappyPeople[,1])) {
nMovements = length(unhappyPeople[,1])
}
sampleIndices = sample(1:length(unhappyPeople[,1]),nMovements)
vacancySamples = sample(1:length(vacant[,1]),nMovements)
for (index in 1:nMovements) {
vacancyIndex = vacancySamples[index]
vacantRow = vacant[vacancyIndex,1]
vacantCol = vacant[vacancyIndex,2]
moverRow = unhappyPeople[sampleIndices[index],1]
moverCol = unhappyPeople[sampleIndices[index],2]
world[vacantRow,vacantCol] = world[moverRow,moverCol]
world[moverRow,moverCol] = -1
}
image(world, col=colors)
} else {
image(world, col=colors)
break
}
}
rows = 100
size = rows^2
world <- matrix(4,nrow=rows,ncol=rows)
world[sample(1:size,round(size*.5))] = 1
world[sample(1:size,round(size*.05))] = -1
bias = matrix(rnorm(size, mean=1/3,sd=1/3),nrow=rows,ncol=rows)
colorFunc = colorRampPalette(c("white","black"))
image(bias,col=colorFunc(10))
colors = c("black","Red","orange","green","blue")
image(world, col=colors)
for (time in 1:1000){
vacant = data.frame()
unhappyPeople = data.frame()
print(time)
for (row in 1:rows) {
for (col in 1:rows) {
value = world[row,col]
if (value > 0) {
neighbors = c(0,0,0,0)
directions = list(c(row + 1, col),
c(row + 1, col + 1),
c(row,     col + 1),
c(row - 1, col + 1),
c(row - 1, col),
c(row - 1, col - 1),
c(row,     col - 1),
c(row + 1, col - 1))
for (directionIndex in 1:8) {
rowN = directions[[directionIndex]][1]
colN = directions[[directionIndex]][2]
# Check for overflows
if (rowN > rows) {
rowN = rowN - rows
} else if (rowN < 1) {
rowN = rows - rowN
}
if (colN > rows) {
colN = colN - rows
} else if (colN < 1) {
colN = rows - colN
}
neighborValue = world[rowN,colN]
if (neighborValue > 0){
neighbors[neighborValue] = neighbors[neighborValue] + 1
}
}
if (value < 3 && sum(neighbors) > 0){
neighborhood = sum(neighbors[1:2]) / sum(neighbors)
if (neighborhood <= bias[row,col]) {
world[row,col] = 2
unhappyPeople = rbind(unhappyPeople,c(row,col))
} else {
world[row,col] = 1
}
} else if (value > 2 && sum(neighbors) > 0) {
neighborhood = sum(neighbors[3:4]) / sum(neighbors)
if (neighborhood <= bias[row,col]) {
unhappyPeople = rbind(unhappyPeople,c(row,col))
world[row,col] = 3
} else {
world[row,col] = 4
}
}
} else {
vacant = rbind(vacant,c(row,col))
}
}
}
if (nrow(unhappyPeople) > 0) {
nMovements = length(vacant[,1])
if ( nMovements > length(unhappyPeople[,1])) {
nMovements = length(unhappyPeople[,1])
}
sampleIndices = sample(1:length(unhappyPeople[,1]),nMovements)
vacancySamples = sample(1:length(vacant[,1]),nMovements)
for (index in 1:nMovements) {
vacancyIndex = vacancySamples[index]
vacantRow = vacant[vacancyIndex,1]
vacantCol = vacant[vacancyIndex,2]
moverRow = unhappyPeople[sampleIndices[index],1]
moverCol = unhappyPeople[sampleIndices[index],2]
world[vacantRow,vacantCol] = world[moverRow,moverCol]
world[moverRow,moverCol] = -1
}
image(world, col=colors)
} else {
image(world, col=colors)
break
}
}
rows = 100
size = rows^2
world <- matrix(4,nrow=rows,ncol=rows)
world[sample(1:size,round(size*.5))] = 1
world[sample(1:size,round(size*.05))] = -1
bias = matrix(1/3,nrow=rows,ncol=rows)
colorFunc = colorRampPalette(c("white","black"))
image(bias,col=colorFunc(10))
colors = c("black","Red","orange","green","blue")
image(world, col=colors)
for (time in 1:1000){
vacant = data.frame()
unhappyPeople = data.frame()
print(time)
for (row in 1:rows) {
for (col in 1:rows) {
value = world[row,col]
if (value > 0) {
neighbors = c(0,0,0,0)
directions = list(c(row + 1, col),
c(row + 1, col + 1),
c(row,     col + 1),
c(row - 1, col + 1),
c(row - 1, col),
c(row - 1, col - 1),
c(row,     col - 1),
c(row + 1, col - 1))
for (directionIndex in 1:8) {
rowN = directions[[directionIndex]][1]
colN = directions[[directionIndex]][2]
# Check for overflows
if (rowN > rows) {
rowN = rowN - rows
} else if (rowN < 1) {
rowN = rows - rowN
}
if (colN > rows) {
colN = colN - rows
} else if (colN < 1) {
colN = rows - colN
}
neighborValue = world[rowN,colN]
if (neighborValue > 0){
neighbors[neighborValue] = neighbors[neighborValue] + 1
}
}
if (value < 3 && sum(neighbors) > 0){
neighborhood = sum(neighbors[1:2]) / sum(neighbors)
if (neighborhood <= bias[row,col]) {
world[row,col] = 2
unhappyPeople = rbind(unhappyPeople,c(row,col))
} else {
world[row,col] = 1
}
} else if (value > 2 && sum(neighbors) > 0) {
neighborhood = sum(neighbors[3:4]) / sum(neighbors)
if (neighborhood <= bias[row,col]) {
unhappyPeople = rbind(unhappyPeople,c(row,col))
world[row,col] = 3
} else {
world[row,col] = 4
}
}
} else {
vacant = rbind(vacant,c(row,col))
}
}
}
if (nrow(unhappyPeople) > 0) {
nMovements = length(vacant[,1])
if ( nMovements > length(unhappyPeople[,1])) {
nMovements = length(unhappyPeople[,1])
}
sampleIndices = sample(1:length(unhappyPeople[,1]),nMovements)
vacancySamples = sample(1:length(vacant[,1]),nMovements)
for (index in 1:nMovements) {
vacancyIndex = vacancySamples[index]
vacantRow = vacant[vacancyIndex,1]
vacantCol = vacant[vacancyIndex,2]
moverRow = unhappyPeople[sampleIndices[index],1]
moverCol = unhappyPeople[sampleIndices[index],2]
world[vacantRow,vacantCol] = world[moverRow,moverCol]
world[moverRow,moverCol] = -1
}
image(world, col=colors)
} else {
image(world, col=colors)
break
}
}
rows = 200
size = rows^2
world <- matrix(4,nrow=rows,ncol=rows)
world[sample(1:size,round(size*.5))] = 1
world[sample(1:size,round(size*.05))] = -1
bias = matrix(1/3,nrow=rows,ncol=rows)
colorFunc = colorRampPalette(c("white","black"))
image(bias,col=colorFunc(10))
colors = c("black","Red","orange","green","blue")
image(world, col=colors)
for (time in 1:1000){
vacant = data.frame()
unhappyPeople = data.frame()
print(time)
for (row in 1:rows) {
for (col in 1:rows) {
value = world[row,col]
if (value > 0) {
neighbors = c(0,0,0,0)
directions = list(c(row + 1, col),
c(row + 1, col + 1),
c(row,     col + 1),
c(row - 1, col + 1),
c(row - 1, col),
c(row - 1, col - 1),
c(row,     col - 1),
c(row + 1, col - 1))
for (directionIndex in 1:8) {
rowN = directions[[directionIndex]][1]
colN = directions[[directionIndex]][2]
# Check for overflows
if (rowN > rows) {
rowN = rowN - rows
} else if (rowN < 1) {
rowN = rows - rowN
}
if (colN > rows) {
colN = colN - rows
} else if (colN < 1) {
colN = rows - colN
}
neighborValue = world[rowN,colN]
if (neighborValue > 0){
neighbors[neighborValue] = neighbors[neighborValue] + 1
}
}
if (value < 3 && sum(neighbors) > 0){
neighborhood = sum(neighbors[1:2]) / sum(neighbors)
if (neighborhood <= bias[row,col]) {
world[row,col] = 2
unhappyPeople = rbind(unhappyPeople,c(row,col))
} else {
world[row,col] = 1
}
} else if (value > 2 && sum(neighbors) > 0) {
neighborhood = sum(neighbors[3:4]) / sum(neighbors)
if (neighborhood <= bias[row,col]) {
unhappyPeople = rbind(unhappyPeople,c(row,col))
world[row,col] = 3
} else {
world[row,col] = 4
}
}
} else {
vacant = rbind(vacant,c(row,col))
}
}
}
if (nrow(unhappyPeople) > 0) {
nMovements = length(vacant[,1])
if ( nMovements > length(unhappyPeople[,1])) {
nMovements = length(unhappyPeople[,1])
}
sampleIndices = sample(1:length(unhappyPeople[,1]),nMovements)
vacancySamples = sample(1:length(vacant[,1]),nMovements)
for (index in 1:nMovements) {
vacancyIndex = vacancySamples[index]
vacantRow = vacant[vacancyIndex,1]
vacantCol = vacant[vacancyIndex,2]
moverRow = unhappyPeople[sampleIndices[index],1]
moverCol = unhappyPeople[sampleIndices[index],2]
world[vacantRow,vacantCol] = world[moverRow,moverCol]
world[moverRow,moverCol] = -1
}
image(world, col=colors)
} else {
image(world, col=colors)
break
}
}
rows = 200
size = rows^2
world <- matrix(4,nrow=rows,ncol=rows)
world[sample(1:size,round(size*.5))] = 1
world[sample(1:size,round(size*.05))] = -1
bias = matrix(1/2,nrow=rows,ncol=rows)
colorFunc = colorRampPalette(c("white","black"))
image(bias,col=colorFunc(10))
colors = c("black","Red","orange","green","blue")
image(world, col=colors)
for (time in 1:1000){
vacant = data.frame()
unhappyPeople = data.frame()
print(time)
for (row in 1:rows) {
for (col in 1:rows) {
value = world[row,col]
if (value > 0) {
neighbors = c(0,0,0,0)
directions = list(c(row + 1, col),
c(row + 1, col + 1),
c(row,     col + 1),
c(row - 1, col + 1),
c(row - 1, col),
c(row - 1, col - 1),
c(row,     col - 1),
c(row + 1, col - 1))
for (directionIndex in 1:8) {
rowN = directions[[directionIndex]][1]
colN = directions[[directionIndex]][2]
# Check for overflows
if (rowN > rows) {
rowN = rowN - rows
} else if (rowN < 1) {
rowN = rows - rowN
}
if (colN > rows) {
colN = colN - rows
} else if (colN < 1) {
colN = rows - colN
}
neighborValue = world[rowN,colN]
if (neighborValue > 0){
neighbors[neighborValue] = neighbors[neighborValue] + 1
}
}
if (value < 3 && sum(neighbors) > 0){
neighborhood = sum(neighbors[1:2]) / sum(neighbors)
if (neighborhood <= bias[row,col]) {
world[row,col] = 2
unhappyPeople = rbind(unhappyPeople,c(row,col))
} else {
world[row,col] = 1
}
} else if (value > 2 && sum(neighbors) > 0) {
neighborhood = sum(neighbors[3:4]) / sum(neighbors)
if (neighborhood <= bias[row,col]) {
unhappyPeople = rbind(unhappyPeople,c(row,col))
world[row,col] = 3
} else {
world[row,col] = 4
}
}
} else {
vacant = rbind(vacant,c(row,col))
}
}
}
if (nrow(unhappyPeople) > 0) {
nMovements = length(vacant[,1])
if ( nMovements > length(unhappyPeople[,1])) {
nMovements = length(unhappyPeople[,1])
}
sampleIndices = sample(1:length(unhappyPeople[,1]),nMovements)
vacancySamples = sample(1:length(vacant[,1]),nMovements)
for (index in 1:nMovements) {
vacancyIndex = vacancySamples[index]
vacantRow = vacant[vacancyIndex,1]
vacantCol = vacant[vacancyIndex,2]
moverRow = unhappyPeople[sampleIndices[index],1]
moverCol = unhappyPeople[sampleIndices[index],2]
world[vacantRow,vacantCol] = world[moverRow,moverCol]
world[moverRow,moverCol] = -1
}
image(world, col=colors)
} else {
image(world, col=colors)
break
}
}
setwd("~/")
data <- read.csv("participation.csv")
mean(data$participation)
data
View(data)
hist(data)
hist(data$participation)
mean(data$participation)
median(data$participation)
boxplot(data$participation)
data <- read.csv("participation.csv")
mean(data$participation)
median(data$participation)
boxplot(data$participation)
data <- read.csv("participation.csv")
mean(data$participation)
median(data$participation)
boxplot(data$participation)
plot(data$participation)
plot(data$participation,type="l")
plot(data$participation,type="b")
plot(data$participation,type="b",pch=19)
plot(data$participation,type="b",pch=19,
xlab="Day of Class",
ylab="Number of Participation Events")
setwd("~/projects/data_analysis/yikyak_analysis")
rm(list=ls())
par(mfrow=c(1,1))
packages <- c('tm','SnowballC','wordcloud')
for (index in 1:length(packages)){
package = packages[index]
exists = require(package,character.only = T)
if (exists == FALSE) {
install.packages(package)
require(package,character.only = T)
}
}
data <- read.csv("savedyaks.csv",header=F,stringsAsFactors=F)
names(data) <- c("ID","string","score")
data <- unique(data)
data$score <- as.numeric(data$score,na.rm=T)
corpus <- VCorpus(VectorSource(data$string))
#inspect(corpus)
# Remove punctionation and convert to lowercase
corpus <- tm_map(corpus, stripWhitespace)
corpus <- tm_map(corpus,content_transformer(tolower))
corpus <- tm_map(corpus, removeWords, append(stopwords("english"),c("just", "like", "get")) )
corpus <- tm_map(corpus,removePunctuation)
# corpusBackup <- corpus
# # Remove stems
# corpus <- tm_map(corpus,stemDocument)
# # Restem to normalize words
# corpus <- tm_map(corpus,stemCompletion, dictionary=corpusBackup)
documentMatrix <- TermDocumentMatrix(corpus, control = list(minWordLength = 1))
#inspect(documentMatrix)
commonWords <- removeSparseTerms(x=documentMatrix, sparse=0.995)
colorfunc <- colorRampPalette(c("#345290","#7f8182","#a7a9ac","#86c1ea"))
m <- as.matrix(commonWords)
v <- sort(rowSums(m), decreasing=T)
documentNames <- names(v)
d <- data.frame(word=documentNames, freq=v)
wordcloud(d$word, d$freq, min.freq=1, col=colorfunc(length(d$word)),
ordered.colors=T,scale=c(5,0.75))
wordcloud(d$word, d$freq, min.freq=1, col=colorfunc(length(d$word)),
ordered.colors=T,scale=c(5,0.75))
classifications = c(0,0,0,14,0,0,0,4844)
barplot(classifications)
barplot(classifications/sum(classifications))
colorfunc <- colorRampPalette(c("#345290","#7f8182","#a7a9ac","#86c1ea"))
barplot(classifications/sum(classifications),
col=colorfunc(8))
